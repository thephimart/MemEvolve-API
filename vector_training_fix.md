# Unit ID Generation Fix - Implementation Plan

## Executive Summary

**Problem**: Unit IDs are generated in multiple places (encoder, vector_store, json_store, graph_store), causing inconsistencies and potential data corruption.

**Solution**: Single Source of Truth - Encoder generates all unit IDs using content-based hashing (same technique as graph store). All storage backends MUST:
1. Accept the ID generated by encoder (if present)
2. Fail if no ID is present (no fallback generation)
3. Never generate their own IDs

### Architecture

```
Graph Store ID Technique (moved to Encoder):
┌─────────────────────────────────────────────────────────────────────┐
│  encoder.encode_experience(experience)                              │
│    │                                                               │
│    ▼                                                               │
│  Generate unit content (normalized)                                │
│    │                                                               │
│    ▼                                                               │
│  SHA256(content) → hexdigest[:16]                                  │
│    │                                                               │
│    ▼                                                               │
│  "unit_<hash>"  e.g., "unit_a1b2c3d4e5f6g7h8"                      │
│    │                                                               │
│    ▼                                                               │
│  ┌────────────────────────────────────────┐                        │
│  │  memory_system.add_experience()        │                        │
│  │    │                                    │                        │
│  │    ▼                                    │                        │
│  │  storage.store(unit)                    │                        │
│  │    │  - ACCEPT ID if present            │                        │
│  │    │  - FAIL if no ID                   │                        │
│  │    │  - NEVER generate new ID           │                        │
│  └────────────────────────────────────────┘                        │
└─────────────────────────────────────────────────────────────────────┘
```

**Advantages**:
- Content-based = automatic deduplication (same experience → same ID)
- Consistent across ALL storage backends
- No counters, no timestamps, no race conditions
- Deterministic (same content always = same ID)

---

## Implementation: Unified Unit ID System

### Phase 1: Fix Encoder (Single Source of Truth)

#### 1.1 Ensure Store Methods Already Receive Unit ID

**Good news**: The existing `store(unit: Dict[str, Any])` method signature passes the complete unit dict which includes the "id" field. Each store extracts the ID from the dict:

```python
# All stores already do this:
unit_id = unit["id"]  # Extract from dict
```

**No method signature changes needed** - just change the fallback logic to error instead.

#### 1.2 Create ID Generation Function in encoder.py

Add new method to `ExperienceEncoder` class:

```python
def _generate_unit_id(self, unit: Dict[str, Any]) -> str:
    """Generate unique unit ID using content hash.
    
    Uses same technique as graph store: SHA256 hash of normalized content.
    This ensures consistent IDs across all storage backends.
    
    Args:
        unit: The memory unit to generate ID for
        
    Returns:
        Unit ID string: "unit_<16-char-hex>"
        Example: "unit_a1b2c3d4e5f6g7h8"
    """
    import hashlib
    import json
    
    # Create normalized content for hashing (exclude ID field itself)
    content_for_hash = {
        "type": unit.get("type", ""),
        "content": unit.get("content", ""),
        "tags": sorted(unit.get("tags", [])),
        "metadata": unit.get("metadata", {})
    }
    
    # Normalize to JSON with consistent ordering
    content_str = json.dumps(content_for_hash, sort_keys=True, default=str)
    
    # Generate SHA256 hash, take first 16 characters
    hash_digest = hashlib.sha256(content_str.encode()).hexdigest()[:16]
    
    return f"unit_{hash_digest}"
```

#### 1.3 Update All encode_* Methods to Use the New Function

Apply to all locations in encoder.py where "id" is set:

| Line | Method | Change |
|------|--------|--------|
| 352 | `encode_experience()` | Replace timestamp ID with `_generate_unit_id()` |
| 591 | `_encode_chunk()` | Replace timestamp ID with `_generate_unit_id()` |
| 629 | `_encode_fallback()` | Replace timestamp ID with `_generate_unit_id()` |
| 748 | `encode_trajectory()` | Replace timestamp ID with `_generate_unit_id()` |
| 755 | `encode_trajectory_batch()` | Replace timestamp ID with `_generate_unit_id()` |
| 784 | `encode_test_memory()` | Replace timestamp ID with `_generate_unit_id()` |

**Pattern for each location:**
```python
# BEFORE (timestamp-based):
"id": f"unit_{int(time.time() * 1000) % 100000}",

# AFTER (content-hash-based):
# Generate ID from content hash (same as graph store technique)
unit_temp = {
    "type": structured_data.get("type", "lesson"),
    "content": extracted_content,
    "tags": extracted_tags,
    "metadata": {...}
}
"id": self._generate_unit_id(unit_temp),
```

#### 1.4 Ensure All Methods Return Units with IDs

Every method that returns a unit MUST include an "id" field. Add validation at the end of each encode method before returning:

```python
# At end of each encode method before returning:
if "id" not in memory_unit:
    memory_unit["id"] = self._generate_unit_id(memory_unit)

### Phase 2: Update Vector Store (Accept-Only)

#### 2.1 Update vector_store.py store() Method

Location: `src/memevolve/components/store/vector_store.py` lines 1183-1189

```python
# BEFORE (generates ID if missing):
if "id" not in unit:
    unit_id = f"unit_{self._next_id}"
    unit["id"] = unit_id
    self._next_id += 1
else:
    unit_id = unit["id"]

# AFTER (accept-only, fail if missing):
if "id" not in unit:
    raise ValueError(
        f"[VECTOR_STORE] Unit must have 'id' field. "
        f"ID generation is the encoder's responsibility.")
unit_id = unit["id"]

# Validate ID format (optional but recommended)
if not unit_id or not isinstance(unit_id, str) or len(unit_id) < 5:
    raise ValueError(
        f"[VECTOR_STORE] Invalid unit ID format: {unit_id}")
```

#### 2.2 Remove ID Generation Code

Remove from vector_store.py:
- Line 61: `_next_id` initialization
- Lines 1108-1110: `_next_id` loading from file
- Lines 1135-1138: `_next_id` saving to file
- Lines 78-91: `_next_id` calculation from data

### Phase 3: Update JSON Store (Accept-Only)

#### 3.1 Update json_store.py store() Method

Location: `src/memevolve/components/store/json_store.py` lines 42-44

```python
# BEFORE (generates ID if missing):
unit_id = unit.get("id", f"unit_{len(self.data)}")
if "id" not in unit:
    unit["id"] = unit_id

# AFTER (accept-only, fail if missing):
if "id" not in unit:
    raise ValueError(
        f"[JSON_STORE] Unit must have 'id' field. "
        f"ID generation is the encoder's responsibility.")
unit_id = unit["id"]
```

### Phase 4: Update Graph Store (Simplify - Use Encoder's ID)

#### 4.1 Simplify graph_store.py store() Method

Location: `src/memevolve/components/store/graph_store.py` lines 89-104

The graph store already uses content hash - now it just needs to use the encoder's ID directly:

```python
# BEFORE (generates ID from content hash internally):
def _get_node_id(self, unit: Dict[str, Any]) -> str:
    content = json.dumps(unit, sort_keys=True, default=str)
    return hashlib.sha256(content.encode()).hexdigest()[:16]

def store(self, unit: Dict[str, Any]) -> str:
    unit_id = self._get_node_id(unit)  # Generates from content

# AFTER (accept-only, use encoder's ID):
def store(self, unit: Dict[str, Any]) -> str:
    # CRITICAL: Accept ID from encoder, never generate
    if "id" not in unit:
        raise ValueError(
            f"[GRAPH_STORE] Unit must have 'id' field. "
            f"ID generation is the encoder's responsibility.")
    unit_id = unit["id"]
    
    # Original hash technique is now in encoder - this is now just storage
```

#### 4.2 Remove Hash-Based ID Generation

Remove from graph_store.py:
- `_get_node_id()` method (no longer needed - logic moved to encoder)
- All calls to `_get_node_id()`

### Phase 5: Update Memory System (Validation)

#### 5.1 Add Pre-Storage Validation

Location: `src/memevolve/memory_system.py` around line 715

```python
def add_experience(self, experience: Dict[str, Any]) -> Optional[str]:
    """Add an experience to memory."""
    try:
        # ... existing code ...
        
        encoded_result = self.encoder.encode_experience(experience)
        
        # CRITICAL: Validate ID presence before storage
        if isinstance(encoded_result, list):
            for i, unit in enumerate(encoded_result):
                if "id" not in unit:
                    raise ValueError(
                        f"[MEMORY_SYSTEM] Encoded unit {i} missing 'id' field. "
                        f"Encoder must generate all unit IDs.")
        else:
            if "id" not in encoded_result:
                raise ValueError(
                    f"[MEMORY_SYSTEM] Encoded unit missing 'id' field. "
                    f"Encoder must generate all unit IDs.")
        
        # ... rest of storage code ...
```

---

## Implementation: IVF Vector Training Fix

*(Previously documented - complementary to ID fix)*

### Current Issues

| Issue | Location | Problem |
|-------|----------|---------|
| Synthetic-only training | `_train_ivf_if_needed` (line 1014) | Never uses real data |
| Mixed synthetic + cache | `_progressive_retrain_index` (line 185) | Adds 20 synthetic vectors to real cache |
| Wrong multiplier | `_generate_system_aligned_training_data` (line 961) | Uses `nlist * 2` instead of `nlist * 39` |

### Solution: Phased Training Strategy

1. **Initial startup** (no real data): Use synthetic training data
2. **Data exists**: Use actual stored vectors for training
3. **Scale target** based on `max_units` configuration

---

## File Changes Summary

| File | Changes |
|------|---------|
| `encoder.py` | Add `_generate_unit_id()` method, update all encode methods to use content-hash IDs |
| `vector_store.py` | Accept-only ID, remove _next_id counter |
| `json_store.py` | Accept-only ID, remove fallback generation |
| `graph_store.py` | Accept-only ID, remove _get_node_id() method |
| `memory_system.py` | Add pre-storage ID validation |
| `config.py` | (Optional) Add IVF training config |

---

## Testing Plan

### Unit Tests
1. Encoder generates deterministic IDs (same content = same ID)
2. Encoder generates unique IDs for different content
3. Storage backends reject units without ID
4. Storage backends accept encoder-generated IDs

### Integration Tests
1. Full flow: experience → encoder → storage
2. Verify same ID in all backends (if using multiple)
3. Verify deduplication works (same experience added twice → same ID)

### Manual Verification
1. Check logs for ID generation in encoder only
2. Verify no ID generation in storage logs
3. Confirm all stored units have valid IDs

---

## Success Criteria

| Criterion | Before | After |
|-----------|--------|-------|
| ID generation location | Multiple (encoder, all stores) | Single (encoder only) |
| ID generation technique | Timestamp or counter | Content hash (same as graph) |
| ID collision risk | High | None (deterministic) |
| Deduplication | Graph only | All backends |
| Data/index mismatch | Possible | Impossible |

---

## Rollback Plan

If issues arise:
1. Revert encoder.py to use timestamp IDs
2. Restore storage fallback ID generation
3. Run ID migration script to standardize

---

**Document Version**: 2.1  
**Updated**: 2026-02-13  
**Status**: Ready for Implementation
